{
    "collab_server" : "",
    "contents" : "####\n#### Exponential distribution\n####\n\n# 1st order Derivative w.r.t. x \nddexp   = function(x,rate) \n{\n  output = rep(0,length(x) )\n  supp = x >=0\n  xs   = x[supp]\n  \n  output[supp] = -rate*dexp(x,rate)\n  return(output)\n}\n\n# 2nd order Derivative w.r.t. x \nd2exp   = function(x,rate) \n{\n  output = rep(0,length(x) )\n  supp = x >=0\n  xs   = x[supp]\n  \n  output[supp] = rate^2*dexp(x,rate)\n  return(output)\n}\n\n# Convex point of the pdf\nconvpt.dlnorm = function(rate) 0\n\n# UpperTuncated Moments \nUpperTruncMomExp = function(a,order,rate) #E[X^iI(x>a)] \n{\n  if (round(order)!= order) \n  {\n    print(\"The order must be an integer\")\n    break\n  }\n  \n  result = 0\n  \n  for (i in 0:order)\n    result = a^i*exp(-rate*a) + i/rate*result\n  \n  output = result\n  \n  return(output)\n}\n####\n#### Log-Normal distribution\n####\n\n# 1st order Derivative w.r.t. x \nddlnorm   = function(x,meanlog,sdlog) \n{\n  output = rep(0,length(x) )\n  supp = x >0\n  xs   = x[supp]\n  \n  output[supp] = -1/x*dlnorm(xs,meanlog,sdlog)*(1 + (log(xs) - meanlog)/sdlog^2)\n  return(output)\n}\n\n# 2nd order Derivative w.r.t. x \nd2lnorm   = function(x,meanlog,sdlog)\n{\n  \n  output = rep(0,length(x) )\n  supp = x >0\n  xs   = x[supp]\n  \n  y = (log(xs) - meanlog)/sdlog + sdlog    \n  output[supp] = -1/(xs^2*sdlog)*dlnorm(xs,meanlog,sdlog)*( (y^2 - 1)/sdlog + y)\n  \n  \n  return(output)\n}\n\n# Convex point of the pdf\nconvpt.dlnorm = function(meanlog,sdlog) exp(meanlog + sdlog*(sqrt(sdlog^2 + 4) - 3*sdlog)/2 )\n\nUpperTruncMomLogN = function(a,order,meanlog,sdlog) #E[X^iI(x>a)] \n{\n  if (round(order)!= order) \n  {\n    print(\"The order must be an integer\")\n    break\n  }\n  \n  \n  result = exp(meanlog*order +  1/2*(sdlog*order)^2)*(1-pnorm( (log(a) - meanlog)/sdlog,sdlog*order,1))\n  output = result\n  \n  return(output)\n}\n####\n#### GPD distribution\n####\n\n# 1st order Derivative w.r.t. x \nddGPD = function(x,xi,beta,u=0) \n{\n  \n  output = rep(0,length(x) )\n  supp = beta+xi*(x-u) >0\n  xs   = x[supp]\n  \n  output[supp] =   -(xi+1)/(beta+xi*(xs-u))*dGPD(xs-u, xi,beta)\n  \n  return(output)\n}\n\n# UpperTuncated Moments \nUpperTruncMomGPD = function(a,order,xi,beta,u=0) #E[X^iI(x>a)] \n{\n  if (round(order)!= order) \n  {\n    print(\"The order must be an integer\")\n    break\n  }\n  \n  xf = u+ qGPD(1,xi,beta)\n  \n  if (order >= 1/xi) {\n    result = Inf\n  }else{\n    \n    \n    result = NA\n    \n    if (order == 0 ) result = 1-pGPD(max(a,u)-u,xi,beta)\n    if (order == 1) \n    {\n      term1 = 1-pGPD(a-u,xi,beta)\n      term2 = max(a,u) - beta/(xi -1)*(1+ xi*(max(a,u) - u)/beta)\n      result = term1*term2*(a<=xf)\n    }\n  }\n  \n  output = result\n  \n  return(output)\n}\n\n\n# CDF of log X when X ~ GPD\nplogGPD = function(q,xi,beta,u=0)  pGPD(exp(q) -u,xi,beta)\ndlogGPD = function(x,xi,beta,u=0)  dGPD(exp(x) -u,xi,beta)*exp(x)\nddlogGPD = function(x,xi,beta,u=0) exp(x)*(exp(x)*ddGPD(exp(x)-u,xi,beta) + dGPD(exp(x) -u,xi,beta) )\n\nqlogGPD = function(p,xi,beta,u=0) log(qGPD(p,xi,beta) + u)\n\n\n####\n#### Pareto distribution\n####\n\n\n#pdf\ndpareto  = function(x,scale=1,shape=1) \n{\n  pdf = rep(NA,length(x))\n  \n  pdf[x == 0] = 0\n  pdf[x != 0] = shape*scale^shape/x^(shape+1)*(scale <= x)\n  \n  output = pdf\n  return(output)\n}\n\n# CDF\nppareto  = function(x,scale=1,shape=1) \n{\n  p = rep(NA,length(x))\n  \n  p[x==0] = 0\n  p[x!=0] = 1 - (scale/x)^shape*(scale <= x)\n  \n  output = p\n  \n  return(output)\n}\n\n# Quantile\nqpareto = function(p,scale=1,shape=1)\n{\n  q = rep(NA,length(p))\n  \n  q[p==1] = Inf\n  q[p==0] = scale\n  q[0<p & p<1] = scale*(1-p[0<p & p<1])^(-1/shape)\n  \n  output = q\n  \n  return(output)\n}\n# 1st order Derivative\nddpareto = function(x,scale=1,shape=1) \n{\n  dpdf = rep(NA,length(x))\n  \n  dpdf[x == 0] = 0\n  dpdf[x != 0] = -(shape+1)/x*dpareto(x,scale,shape)\n  \n  output = dpdf\n  \n  return(output)\n}\n\n# UpperTuncated Moments \nUpperTruncMomPareto = function(a,order,scale=1,shape = 1) #E[X^iI(x>a)] \n{  \n  uppMoments = rep(NA,length(order))\n  \n  # Case when the order is larger or equal than the shape\n  uppMoments[(order >= shape)] = Inf\n  \n  # Case when the order is strictly smaller than the shape\n  ind = which(order < shape)\n  uppMoments[ind]  = shape*scale^shape/(shape-order[ind])*max(a,scale)^(order[ind]-shape)\n  \n  output = uppMoments\n  return(output)\n}\n\n\n# # 1st order Derivative w.r.t. x \n# ddpareto = function(x,shape,scale) \n# {\n#   output = -(shape+1)/(x+scale)*dpareto(x,shape,scale)\n#   #dpareto is a function of the package actuar\n#   return(output)\n# }\n\n####\n#### Gamma distribution\n####\n\n# 1st order Derivative w.r.t. x \nddgamma  = function(x,shape,rate) \n{\n  \n  output = rep(0,length(x) )\n  supp = x>0\n  xs   = x[supp]\n  \n  output[supp] =   ((shape-1)/xs - rate)*dgamma(xs,shape,rate)\n  \n  return(output)\n}\n\n# 2nd order Derivative w.r.t. x \nd2dgamma = function(x,shape,rate)\n{\n  output = rep(0,length(x) )\n  supp = x>0\n  xs   = x[supp]\n  \n  output[supp] =  1/xs^2*( (shape-1 -rate*xs)^2 - shape + 1 )*dgamma(xs,shape,rate)\n}\n\n# Convex point of the pdf\nconvpt.dgamma =  function(shape,rate) ((shape - 1) + sqrt(shape-1))/rate\n\n####\n#### Log-Gamma distribution <=> log X ~ Gamma\n####\n\n# 1st order Derivative w.r.t. x \nddlgamma  = function(x,shapelog,ratelog) \n{\n  output = rep(0,length(x) )\n  supp = x>1\n  xs   = x[supp]\n  \n  output[supp] =  1/xs*(-1 -ratelog + (shapelog-1)/log(xs) )*dlgamma(xs,shapelog,ratelog)\n  return(output)\n}\n\n# 2nd order Derivative w.r.t. x \nd2dlgamma = function(x,shapelog,ratelog) \n{\n  r = ratelog  + 1\n  s = shapelog - 1\n  \n  output = rep(0,length(x) )\n  supp = x>1\n  xs   = x[supp]\n  \n  output[supp] = 1/(xs*log(xs))^2*( log(xs)^2*r*(r+1) - log(xs)*s*(1 + 2*r) + s*(s-1))*dlgamma(xs,shapelog,ratelog)\n  return(output)\n}\n\n# Convex point of the pdf\nconvpt.dlgamma = function(shapelog,ratelog)\n{\n  r = ratelog  + 1\n  s = shapelog - 1\n  \n  c0 =  s*(s-1)\n  c1 = -s*(1 + 2*r) \n  c2 =  r*(r+1)\n  \n  sol_quad_eq = Re(polyroot(c(c0,c1,c2)))\n  output = exp(max(sol_quad_eq))\n  \n  return(output)\n}\n\n\n####\n#### Beta distribution \n####\n# 1st order Derivative w.r.t. x \nddbeta  = function(x,shape1,shape2) \n{\n  output = rep(0,length(x) )\n  \n  supp = 0<x & x <1\n  xs   = x[supp]\n  \n  output[supp] = dbeta(xs,shape1,shape2)*((shape1 - 1)/xs - (shape2 - 1)/(1-xs))\n  \n  return(output)\n}\n\nd2dbeta  = function(x,shape1,shape2) \n{\n  output = rep(0,length(x) )\n  \n  supp = 0<x & x <1\n  xs   = x[supp]\n  \n  output[supp] = dbeta(xs,shape1,shape2)*(((shape1 - 1)/xs + (shape2 - 1)/(1-xs))^2 -(shape2-1)/(1-xs)^2\n                                          - (shape1-1)/xs^2)  \n  return(output)\n}\n\n####\n#### \"Hill Horror Plot\" distribution\n#### F(x) = 1 - 1/(x log x)\n####\n\nf_inv_horror_dist = function(d)\n{\n  # Define the interval in which to search for the root\n  lower = sqrt(d)\n  upper = max(exp(1),d)\n  \n  output = uniroot( function(x,d)x*log(x) -d, d = d, interval = c(lower,upper))$root\n  return(output)\n}\n\n\n\n# Using the inversion CDF method, we simulate \n# a sample\nrhorror = function(n)\n{\n  U = runif(n)\n  d = 1/(1-U)\n  \n  output = sapply(d,f_inv_horror_dist )\n  return(output)\n}\n\n# Check that the simulation is accurate\n# X = sort(simulate_horror_dist(1e5))\n# Fn = ecdf(X)\n# plot(Fn,xlim = c(f_inv(1),max(X)),log = \"x\" )\n# lines(X,1- 1/(X*log(X)),col = \"red\"   )\n\nqhorror   = function(p) \n{ \n  q = rep(NA,length(p))\n  q[p==1] = Inf\n  \n  ind = 0 <= p & p <1\n  q[ind] =  sapply(1/(1-p[ind]),f_inv_horror_dist)\n  \n  output = q\n  return(output)\n}\n\nphorror   = function(x)\n{\n  xmin = qhorror(0)\n  ind_supp = which(x>= xmin) \n  \n  output = rep(0,length(x))\n  z = x[ind_supp]\n  output[ind_supp] = 1- 1/(z*log(z))\n  \n  return(output)                      \n}\n\ndhorror   = function(x){\n  \n  xmin = qhorror(0)\n  ind_supp = which(x>= xmin) \n  \n  output = rep(0,length(x))\n  z = x[ind_supp]\n  output[ind_supp] = (log(z)+1)/(z*log(z))^2\n  \n  return(output)\n} \n\nddhorror  = function(x) {\n  xmin = qhorror(0)\n  ind_supp = which(x>= xmin) \n  output = rep(0,length(x))\n  \n  z = x[ind_supp]\n  output[ind_supp] = (log(z) - 2*(log(z)+1)^2)/(z*log(z))^3\n  return(output)\n  \n}\n\nd2dhorror = function(x){\n  xmin = qhorror(0)\n  ind_supp = which(x>= xmin) \n  output = rep(0,length(x))\n  \n  z = x[ind_supp]\n  output[ind_supp] =(6*(log(z)+1)^3 -6*log(z) -7*log(z)^2 )/(z*log(z))^4\n  return(output)\n  \n}\n\nUpperTruncHorrorMoment = function(a,order,seed, eps = 1e-4)\n{  \n  xmin = qhorror(0)\n  A = pmax(a,xmin)\n  \n  if (order >= 1) output = Inf\n  if (order < 1)  \n  {\n    if (order == 0) output =  1 - phorror(A)\n    else {\n      rate = (1-order)*log(A)\n      if (rate>=1)  output = as.numeric(A^(order - 1)/log(A) + order*gammainc(rate,0)[2])\n      if (rate< 1){\n        \n        if (!missing(seed)) set.seed = seed\n        X = rexp(1e7,rate)\n        sig = sd(1/X*(X>=1))\n        nsam = (2*qnorm(0.975)*sig/(eps*rate))^2\n        \n        if (!missing(seed)) set.seed = seed\n        X = rexp(nsam,rate) \n        output =  A^(order - 1)/log(A) + order*mean(1/X*(X>=1))/rate\n      }\n    }\n  }\n  return(output)\n}\n\n###\n### Horror Hill distribution with log-transform\n###\n\n# Check that the simulation is accurate\n# X = sort(simulate_horror_dist(1e5))\n# Fn = ecdf(X)\n# plot(Fn,xlim = c(f_inv(1),max(X)),log = \"x\" )\n# lines(X,1- 1/(X*log(X)),col = \"red\"   )\n\nqlhorror   = function(p) \n{ \n  output = log(qhorror(p))\n  return(output)\n}\n\nplhorror   = function(x)\n{\n  output = phorror(exp(x))\n  return(output)                      \n}\n\ndlhorror   = function(x){\n  output = exp(x)*dhorror(exp(x))\n  return(output)\n} \n\nddlhorror  = function(x) {\n  output =  exp(2*x)*ddhorror(exp(x))+ exp(x)*dhorror(exp(x))\n  return(output)\n  \n}\n\nd2dlhorror = function(x){\n  output = exp(3*x)*d2dhorror(exp(x)) + 3*exp(2*x)*ddhorror(exp(x)) + exp(x)*dhorror(exp(x))\n  return(output)\n  \n}\n\nUpperTrunclHorrorMoment = function(a,order,seed, eps = 1e-4)\n{  \n  xmin = qlhorror(0)\n  A = pmax(a,xmin)\n  \n  if (order <0){ print(\"The order must be non-negative\") ; return(NA)} else\n  {\n    if (order == 0) output = 1 - plhorror(A)\n    if (order == 1) {\n      if (A > 1)  output = exp(-A) + as.numeric(gammainc(A,0)[2])\n      if (A <= 1) output = exp(-A) + integrate(function(x)exp(-x)/x,lower = A,upper = Inf)$value\n    }\n    \n    if ( !(order %in% c(0,1)) ) output = (1+ 1/(order-1))*as.numeric(gammainc(A,order)[2]) -  A^(order -1)*exp(-A)/(order-1)\n  }\n  return(output)\n}\n",
    "created" : 1475186691101.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2618904695",
    "id" : "1EE85E6B",
    "lastKnownWriteTime" : 1473880633,
    "last_content_update" : 1473880633,
    "path" : "/src/BU/src/Functions/distributions_prop.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}